(ns eclj.ext
  (:refer-clojure :exclude [eval])
  (:require [eclj.common :refer (map->Syntax)]
            [eclj.ns]))

(defn ns-env []
  (eclj.env/ns-env))

;;XXX quasi-primitive
(defmacro raise [effect]
  `(eclj.ext/raise ~effect))

(defn handle-with* [handler thunk]
  (let [eff (eclj.ext/eval-effect (list thunk) (assoc (ns-env) :kernel nil))]
    (raise (or (handler eff) eff))))

(defmacro handle-with [handler & body]
  `(handle-with* ~handler (fn [] ~@body)))

(defn continue [k x]
  (raise (trampoline k x)))

(defn eval
  "Like eclj.core/eval, but supports raising effects and accepts an optional
   environment as a second argument."
  ([form] (eval form (ns-env)))
  ([form env]
   (raise (eclj.ext/eval-effect form env))))
