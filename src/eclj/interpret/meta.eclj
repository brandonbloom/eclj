(ns eclj.interpret.meta
  (:refer-clojure :exclude [eval])
  (:require [eclj.common :refer (map->Syntax)]
            [eclj.parse :refer (parse)]
            [eclj.fn]
            [eclj.ext]))

;;TODO: parse doesn't preserve metadata correctly. Fix & match cps' answer def.
(def answer
  (with-meta
    (fn [x] {:op :answer :value x})
    {:eclj/answer true}))

;; Necessary because eclj.interpret.meta redefines answer symbolically.
(defn tail-effect? [effect]
  (-> effect :k meta :eclj/answer))

(defmulti interpret-syntax :head)

(defn interpret [x env]
  (interpret-syntax (parse x env)))

(defn thunk [expr env]
  #(interpret expr env))

(defn thunk-syntax [syntax]
  (thunk (map->Syntax syntax) (:env syntax)))

(defmulti -apply (fn [f arg] (class f)))

(defn run [x env]
  ;(println "meta run:")
  ;(fipp.edn/pprint x)
  (loop [f (thunk x env)]
    (let [x (f)]
      (if (fn? x)
        (recur x)
        (let [{:keys [op k]} x]
          (if-let [handler (get-in env [:kernel op])]
            (recur #(k (handler x)))
            x))))))

(defn eval [x env]
  ;(println "meta eval:")
  ;(fipp.edn/pprint (parse x env))
  (eclj.ext/raise (run x env)))

(defn eval-syntax [syntax]
  (eval (map->Syntax syntax) (:env syntax)))

(defn result [effect]
  (case (:op effect)
    :answer (:value effect)
    :throw (throw (:error effect))
    (throw (ex-info (pr-str effect) effect))))

(def interpreter
  {:result (fn [x env]
             (result (run x env)))
   :effect run})

(defn raise [action]
  (merge {:k answer} action))

;;TODO: Implement restarts, etc.
(defn signal [condition]
  (raise (merge {:op :condition} condition)))

(defn handle-with [handler effect k]
  (let [f (partial handle-with handler)]
    (if (fn? effect)
      #(f (effect) k)
      (or (handler effect k)
          (assoc effect :k #(f ((:k effect) %) k))))))

(defn default-handler [effect k]
  (when (= (:op effect) :answer)
    #(k (:value effect))))

(defn handle [effect k]
  (handle-with default-handler effect k))

(defn lookup [{:keys [locals] :as env} sym]
  (if-let [[_ value] (find locals sym)]
    (answer {:origin :locals :value value})
    (raise {:op :resolve
            :env env
            :sym sym
            :k #(if %
                  (answer %)
                  (signal {:error :undefined :sym sym}))})))

(defmethod interpret-syntax :constant
  [{:keys [value]}]
  (answer value))

(defn interpret-items [coll env]
  (answer (into (empty coll) (map #(eval % env) coll))))

(defmethod interpret-syntax :collection
  [{:keys [coll env]}]
  (interpret-items coll env))

(defn macro? [{:keys [origin value]}]
  (and (= origin :namespace) (-> value meta :macro)))

(defmethod interpret-syntax :name
  [{:keys [sym env]}]
  (let [{:keys [origin value] :as resolved} (eclj.ext/raise (lookup env sym))]
    (if (macro? resolved)
      (signal {:error :value-of-macro :name sym})
      (case origin
        :locals (answer value)
        :host (answer value)
        :namespace (raise {:op :deref :ref value})))))

(defmethod interpret-syntax :if
  [{:keys [test then else env]}]
  (answer (eval (if (eval test env) then else) env)))

(defmethod interpret-syntax :var
  [{:keys [sym env]}]
  (let [{:keys [origin value]} (eclj.ext/raise
                                 {:op :resolve :env env :sym sym})]
    (assert (= origin :namespace))
    (answer value)))

(defmethod interpret-syntax :do
  [{:keys [statements ret env]}]
  (doseq [statement statements]
    (eval statement env))
  (answer (eval ret env)))

(defmethod interpret-syntax :bind
  [{:keys [name value expr env]}]
  (answer (eval expr (assoc-in env [:locals name] value))))

(defmethod interpret-syntax :let
  [{:keys [bindings expr env]}]
  (answer
    (if-let [[{:keys [name init]} & bindings*] (seq bindings)]
      (let [value (eval init env)]
        (eval-syntax {:head :let :env (assoc-in env [:locals name] value)
                      :bindings (vec bindings*) :expr expr}))
      (eval expr env))))

(defmethod -apply Object
  [f arg]
  (signal {:error :not-callable :f f :args arg}))

(defmethod -apply clojure.lang.IFn
  [f arg]
  (raise {:op :invoke :f f :args arg}))

(defmethod -apply clojure.lang.Var
  [f arg]
  (handle (raise {:op :deref :ref f})
          #(-apply % arg)))

(defn recur-handler [f env]
  (fn [effect]
    (when (= (:op effect) :recur)
      (if (tail-effect? effect)
        (eval-syntax {:head :apply :f f :arg (:args effect) :env env})
        (eclj.ext/raise
          (signal {:error :non-tail-position}))))))

(defmethod -apply eclj.fn.Fn
  [{:keys [name arities max-fixed-arity env] :as f} args]
  (let [argcount (count (if (counted? args)
                          args
                          (take max-fixed-arity args)))
        {:keys [params expr]} (arities (min argcount max-fixed-arity))
        env* (if name (assoc-in env [:locals name] f) env)
        ;;TODO: Don't generate form, destructure to env & use AST directly.
        form `(let [~params '~args] ~expr)]
    ;(eclj.ext/handle-with (recur-handler f env) ;XXX ================
      (answer (eval form env*))
      ))

(defmethod interpret-syntax :letfn
  [{:keys [bindings expr env]}]
  (thunk expr (update-in env [:locals] merge bindings)))

(defn exception-handler [catches default finally env]
  (fn handler [{:keys [op] :as effect} k]
    (case op
      :answer #(handle (thunk finally env)
                       (fn [_] (fn [] (k (:value effect)))))
      :throw (let [error (:error effect)
                   catch (some (fn [{:keys [class sym expr] :as catch}]
                                 (when (instance? class error) catch))
                                 catches)]
               (when-let [{:keys [name expr]} (or catch default)]
                 #(handle (thunk-syntax {:head :bind :env env
                                         :name name :value error :expr expr})
                          (fn [y]
                            (handle (thunk finally env)
                                    (fn [_] (k y)))))))
      nil)))

(defmethod interpret-syntax :try
  [{:keys [try catches default finally env]}]
  (handle (interpret-items (mapv :type catches) env)
          (fn [classes] ;TODO: Ensure items are exception classes.
            (let [catches* (map #(assoc %1 :class %2) catches classes)]
              (handle-with (exception-handler catches* default finally env)
                           (thunk try env) answer)))))

(defmethod interpret-syntax :raise
  [{:keys [expr env]}]
  (handle (thunk expr env) raise))

(defn apply-args [f args env]
  (handle (interpret-items (reverse args) env)
          #(thunk-syntax {:head :apply :f f :arg % :env env})))

(defmethod interpret-syntax :apply
  [{:keys [f arg]}]
  (-apply f arg))

(defmethod interpret-syntax :invoke
  [{:keys [f args env form]}]
  (if (symbol? f)
    (handle (lookup env f)
            #(let [{:keys [value] :as resolved} %]
               (if (macro? resolved)
                 (thunk-syntax {:head :expand :macro value
                                :form form :env env})
                 (apply-args value args env))))
    (handle (thunk f env)
            #(apply-args % args env))))

;;TODO: Replace expand special with Applicable Macro type?
(defmethod interpret-syntax :expand
  [{:keys [macro form env]}]
  (handle (thunk-syntax {:head :apply :env env :f macro
                         :arg (list* form env (next form))})
          #(thunk % env)))

(defmethod interpret-syntax :new
  [{:keys [class args env]}]
  (handle (thunk class env)
          (fn [class*] ;TODO: Validate
            (fn []
              (handle (interpret-items args env)
                      #(raise {:op :new :class class* :args %}))))))

(defmethod interpret-syntax :interop
  [{:keys [target member args env]}]
  (handle (thunk target env)
          (fn [object]
            (handle (interpret-items (vec args) env)
                    #(raise {:op :interop
                             :object object
                             :member member
                             :args %})))))

(defn interpret-meta [x env]
  (handle (thunk (meta x) env)
          #(answer (with-meta x %))))

(defmethod interpret-syntax :declare
  [{:keys [sym env]}]
  (handle (interpret-meta sym env)
          #(raise {:op :declare :sym %})))

(defmethod interpret-syntax :define
  [{:keys [sym expr env]}]
  (handle (thunk expr env)
          (fn [value]
            (handle (interpret-meta sym env)
                    #(raise {:op :define :sym % :value value})))))

(defmethod interpret-syntax :assign-var
  [{:keys [name expr env]}]
  (handle (lookup env name)
          (fn [{:keys [origin value]}]
            (if (= origin :namespace)
              (handle (thunk expr env)
                      #(raise {:op :assign-var :var value :value %}))
              (signal {:error :not-assignable :location value})))))

(defmethod interpret-syntax :assign-field
  [{:keys [object field expr env]}]
  (handle (thunk object env)
          (fn [instance]
            (handle (thunk expr env)
                    #(raise {:op :assign-field :object instance
                             :field field :value %})))))

(defmethod interpret-syntax :loop
  [{:keys [bindings expr env]}]
  (let [syms (vec (take-nth 2 bindings))
        inits (vec (take-nth 2 (next bindings)))
        values (eclj.ext/raise (interpret-items inits env))]
    ;;TODO: Generate AST directly instead of syntax forms.
    (answer (eval `((fn ~syms ~expr) ~@(map #(list 'quote %) values)) env))))

(defmethod interpret-syntax :recur
  [{:keys [args env]}]
  (let [args (interpret-items args env)]
    (answer (eclj.ext/raise {:op :recur :args args}))))

(defmethod interpret-syntax :import
  [{:keys [sym]}]
  (raise {:op :import :sym sym}))

(defmethod interpret-syntax :case
  [{:keys [expr cases default env]}]
  (handle (thunk expr env)
          (fn [value]
            (if-let [[_ match] (find cases value)]
              (thunk match env)
              (thunk default env)))))
