(ns eclj.interpret.meta
  (:refer-clojure :exclude [eval])
  (:require [eclj.common :refer (map->Syntax)]
            [eclj.parse :refer (parse)]
            [eclj.fn]
            [eclj.ext :refer (handle-with raise)]))

(def answer ^:eclj/answer
  (fn [x] {:op :answer :value x}))

;; Necessary because eclj.interpret.meta redefines answer symbolically.
(defn tail-effect? [effect]
  (-> effect :k meta :eclj/answer))

(defmulti eval-head :head)

(defn eval [x env]
  (eval-head (parse x env)))

(defn eval-syntax [syntax]
  (eval (map->Syntax syntax) (:env syntax)))

(defmulti -apply (fn [f arg] (class f)))

(defn kernel-handler [kernel]
  (fn [{:keys [op k] :as effect}]
    (if-let [f (get kernel op)]
      (k (f effect))
      (answer effect))))

(defn eval-result [x env]
  (handle-with (kernel-handler (:kernel env))
    (eval x env)))

(defn eval-effect [x env]
  (handle-with answer (eval-result x env)))

(def evaluator
  {:result eval-result
   :effect eval-effect})

;;TODO: Implement restarts, etc.
(defn signal [condition]
  (raise (merge {:op :condition} condition)))

(defn lookup [{:keys [locals] :as env} sym]
  (if-let [[_ value] (find locals sym)]
    {:origin :locals :value value}
    (or (raise {:op :resolve :env env :sym sym})
        (signal {:error :undefined :sym sym}))))

(defmethod eval-head :constant
  [{:keys [value]}]
  value)

(defn eval-items [coll env]
  (into (empty coll) (map #(eval % env) coll)))

(defmethod eval-head :collection
  [{:keys [coll env]}]
  (eval-items coll env))

(defn macro? [{:keys [origin value]}]
  (and (= origin :namespace) (-> value meta :macro)))

(defmethod eval-head :name
  [{:keys [sym env]}]
  (let [{:keys [origin value] :as resolved} (lookup env sym)]
    (if (macro? resolved)
      (signal {:error :value-of-macro :name sym})
      (case origin
        :locals value
        :host value
        :namespace (raise {:op :deref :ref value})))))

(defmethod eval-head :if
  [{:keys [test then else env]}]
  (eval (if (eval test env) then else) env))

(defmethod eval-head :var
  [{:keys [sym env]}]
  (let [{:keys [origin value]} (raise {:op :resolve :env env :sym sym})]
    (assert (= origin :namespace))
    value))

(defmethod eval-head :do
  [{:keys [statements ret env]}]
  (doseq [statement statements]
    (eval statement env))
  (eval ret env))

(defmethod eval-head :bind
  [{:keys [name value expr env]}]
  (eval expr (assoc-in env [:locals name] value)))

(defmethod eval-head :let
  [{:keys [bindings expr env]}]
  (if-let [[{:keys [name init]} & bindings*] (seq bindings)]
    (let [value (eval init env)]
      (eval-syntax {:head :let :env (assoc-in env [:locals name] value)
                    :bindings (vec bindings*) :expr expr}))
    (eval expr env)))

(defmethod -apply Object
  [f arg]
  (signal {:error :not-callable :f f :args arg}))

(defmethod -apply clojure.lang.IFn
  [f arg]
  (raise {:op :invoke :f f :args arg}))

(defmethod -apply clojure.lang.Var
  [f arg]
  (-apply (raise {:op :deref :ref f}) arg))

(defn recur-handler [f env]
  (fn [effect]
    (when (= (:op effect) ::recur)
      (if (tail-effect? effect)
        (eval-syntax {:head :apply :f f :arg (:args effect) :env env})
        (signal {:error :non-tail-position})))))

(defmethod -apply eclj.fn.Fn
  [{:keys [name arities max-fixed-arity env] :as f} args]
  (let [argcount (count (if (counted? args)
                          args
                          (take max-fixed-arity args)))
        {:keys [params expr]} (arities (min argcount max-fixed-arity))
        ;;TODO: port arity checking code from cps interpreter.
        env* (if name (assoc-in env [:locals name] f) env)
        ;;TODO: Don't generate form, destructure to env & use AST directly.
        form `(let [~params '~args] ~expr)]
    (handle-with (recur-handler f env) (eval form env*))))

(defmethod eval-head :letfn
  [{:keys [bindings expr env]}]
  (eval expr (update-in env [:locals] merge bindings)))

(defn exception-handler [catches default finally env]
  (fn handler [{:keys [op] :as effect}]
    (case op
      :answer (do (eval finally env) nil)
      :throw (let [error (:error effect)
                   catch (some (fn [{:keys [class sym expr] :as catch}]
                                 (when (instance? class error) catch))
                                 catches)]
               (when-let [{:keys [name expr]} (or catch default)]
                 (let [ret (eval-syntax {:head :bind :env env
                                         :name name :value error :expr expr})]
                   (eval finally env)
                   (answer ret))))
      nil)))

(defmethod eval-head :try
  [{:keys [try catches default finally env]}]
  ;;TODO: Ensure items are exception classes.
  (let [classes (eval-items (mapv :type catches) env)
        catches* (map #(assoc %1 :class %2) catches classes)
        handler (exception-handler catches* default finally env)]
    (handle-with handler (eval try env))))

(defmethod eval-head :handle-with
  [{:keys [handler expr env]}]
  (handle-with (eval handler env) (eval expr env)))

(defmethod eval-head :raise
  [{:keys [expr env]}]
  (raise (eval expr env)))

(defmethod eval-head :apply
  [{:keys [f arg]}]
  (-apply f arg))

(defn apply-args [f args env]
  (let [values (eval-items (reverse args) env)]
    (eval-syntax {:head :apply :f f :arg values :env env})))

(defmethod eval-head :invoke
  [{:keys [f args env form]}]
  (if (symbol? f)
    (let [{:keys [value] :as resolved} (lookup env f)]
      (if (macro? resolved)
        (eval-syntax {:head :expand :macro value
                      :form form :env env})
        (apply-args value args env)))
    (apply-args (eval f env) args env)))

;;TODO: Replace expand special with Applicable Macro type?
(defmethod eval-head :expand
  [{:keys [macro form env]}]
  (let [expanded (eval-syntax {:head :apply :env env
                               :f macro :arg (list* form env (next form))})]
    (eval expanded env)))

(defmethod eval-head :new
  [{:keys [class args env]}]
  (let [class* (eval class env)
        args* (eval-items args env)]
    (raise {:op :new :class class* :args args*})))

(defmethod eval-head :interop
  [{:keys [target member args env]}]
  (let [object (eval target env)
        args* (eval-items (vec args) env)]
    (raise {:op :interop :object object :member member :args args*})))

(defn eval-meta [x env]
  (with-meta x (eval (meta x) env)))

(defmethod eval-head :declare
  [{:keys [sym env]}]
  (let [sym* (eval-meta sym env)]
    (raise {:op :declare :sym sym*})))

(defmethod eval-head :define
  [{:keys [sym expr env]}]
  (let [value (eval expr env)
        sym* (eval-meta sym env)]
    (raise {:op :define :sym sym* :value value})))

(defmethod eval-head :assign-var
  [{:keys [name expr env]}]
  (let [{:keys [origin] loc :value} (lookup env name)]
    (if (= origin :namespace)
      (let [value (eval expr env)]
        (raise {:op :assign-var :var loc :value value}))
      (signal {:error :not-assignable :location loc}))))

(defmethod eval-head :assign-field
  [{:keys [object field expr env]}]
  (let [instance (eval object env)
        value (eval expr env)]
    (raise {:op :assign-field :object instance :field field :value value})))

(defmethod eval-head :loop
  [{:keys [bindings expr env]}]
  (let [syms (vec (take-nth 2 bindings))
        inits (vec (take-nth 2 (next bindings)))
        values (eval-items inits env)]
    ;;TODO: Generate AST directly instead of syntax forms.
    (eval `((fn ~syms ~expr) ~@(map #(list 'quote %) values)) env)))

(defmethod eval-head :recur
  [{:keys [args env]}]
  (let [args (eval-items args env)]
    (raise {:op ::recur :args args})))

(defmethod eval-head :import
  [{:keys [sym]}]
  (raise {:op :import :sym sym}))

(defmethod eval-head :case
  [{:keys [expr cases default env]}]
  (let [value (eval expr env)
        body (if-let [[_ match] (find cases value)] match default)]
    (eval body env)))

(defmethod eval-head :meta
  [{:keys [expr meta env]}]
  (with-meta (eval expr env) (eval meta env)))
